#!/bin/sh
#
# relevanced  Start/Stop the relevanced daemon.
#
# chkconfig: 345 90 60
# Description:
#  relevanced is a fast text similarity-scoring server
#  with persistent document centroids.
#
### BEGIN INIT INFO
# Provides: relevanced
# Required-Start: $local_fs $syslog
# Required-Stop: $local_fs $syslog
# Default-Start:  345
# Default-Stop: 90
# Short-Description: run relevanced daemon
# Description:
#  relevanced is a fast text similarity-scoring server
#  with persistent document centroids.
#
### END INIT INFO

if [ -z $RETVAL ]; then RETVAL=0; fi
if [ -z $PROG ]; then PROG="relevanced"; fi
if [ -z $EXEC ]; then EXEC=/usr/bin/relevanced; fi
if [ -z $REAL_CONFIG_PATH ]; then REAL_CONFIG_PATH=/etc/relevanced/relevanced.json; fi
if [ -z $LOCKFILE ]; then LOCKFILE=/var/lock/relevanced; fi
if [ -z $PIDFILE ]; then PIDFILE=/var/run/relevanced.pid; fi
if [ -z $UID ]; then UID=$(id -u); fi

if [ $UID -eq 0 ] && [ -e /etc/sysconfig/$PROG ]; then
  . /etc/sysconfig/$PROG
fi

if [ -e /etc/init.d/functions ]; then
  . /etc/init.d/functions
fi

if [ ! -e $FLAGS_PATH ] && [ ! -e $REAL_CONFIG_PATH ]; then
  echo "No config file found at $REAL_CONFIG_PATH"
  RETVAL=1
fi

ensure_root() {
  if [ $UID -ne 0 ] ; then
    echo "User has insufficient privilege."
    RETVAL=1
  fi
}

start() {
  ensure_root

  ARGS=""
  if [ -f $PIDFILE ]; then
    PID=$(cat $PIDFILE)
    PROCNAME=$(ps -p $PID -o comm\=)
    if [ "$PROCNAME" = "$PROG" ]; then
      return 0
    else
      # pidfile exists but it's not running
      rm $PIDFILE
    fi
  fi

  # if [ -e $FLAGS_PATH ]; then ARGS="$ARGS --flagfile=$FLAGS_PATH"; fi
  if [ -e $REAL_CONFIG_PATH ]; then ARGS="$ARGS --config_file=$REAL_CONFIG_PATH"; fi

  $PROG $ARGS \
        --pidfile=$PIDFILE \
        --daemonize=true
  RETVAL=$?
}

stop() {
  ensure_root

  if [ ! -f $PIDFILE ] ; then
    RETVAL=0
  else
    PID=$(cat $PIDFILE)
    # Terminate the daemon and watchers
    pkill -g $PID
    # Allow the event threads to tear down
    ( while kill -0 $PID >/dev/null 2>&1; do sleep 0.2; done ) & DPID=$!
    # If the event threads are still running after 5 seconds, kill them
    ( sleep 5 && pkill -9 -g $PID && kill -9 $DPID ) 2>/dev/null & WPID=$!
    if wait $DPID 2>/dev/null; then
      pkill -9 -P $WPID
      wait $WPID
    fi
    rm -f $PIDFILE
  fi
}

restart() {
  stop
  start
}

status() {
  if [ ! -f $PIDFILE ] ; then
    echo "$PROG is not running. no pidfile found."
    RETVAL=7
  else
    PID=$(cat $PIDFILE)
    PROCNAME=$(ps -p $PID -o comm\=)
    if [ "$PROCNAME" = "$PROG" ]; then
      echo "$PROG is already running: $PID"
      RETVAL=0
    else
      # pidfile exists but it's not running
      echo "$PROG is not running but a stale pidfile was found."
      RETVAL=7
    fi
  fi
}

usage() {
  echo "Usage: $0 {start|stop|status|restart}"
  RETVAL=2
}

case "$1" in
    start) start ;;
    stop) stop ;;
    restart) restart ;;
    status) status ;;
    *) usage ;;
esac

exit ${RETVAL}
